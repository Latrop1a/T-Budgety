/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view */ \"./src/view.js\");\n/*\r\nBudget App with ES5 Syntax\r\n\r\nFeature Ideas:\r\n-update into proper es6 and modules (medium)\r\n-webpack, npm\r\n-Delete all (done)\r\n-loop to make the thousand marker work with big numbers(done)\r\n\r\n-Date picker(medium?)\r\n-add categories and a chart split into the categories (hard)\r\n-add months dropdown with temp storing of months (hard?)\r\n-edit button on each list element (medium?)\r\n\r\n-add users and saving of data via NODE JS (very hard)\r\n\r\n\r\n*/\n\nconsole.log(_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); // BUDGET CONTROLLER\n\nlet budgetController = function () {\n  // Expense Constructor\n  class Expense {\n    constructor(id, description, value) {\n      this.id = id;\n      this.description = description;\n      this.value = value;\n      this.percentage = -1; //not yet defined\n    } // Method: Calculate percentage from total\n\n\n    calcPercentage(totalIncome) {\n      if (totalIncome > 0) {\n        this.percentage = Math.round(this.value / totalIncome * 100);\n      } else {\n        this.percentage = -1;\n      }\n    }\n\n    getPercentage() {\n      return this.percentage;\n    }\n\n  } // Income Contructor\n\n\n  class Income {\n    constructor(id, description, value) {\n      this.id = id;\n      this.description = description;\n      this.value = value;\n    }\n\n  }\n\n  let data = {\n    allItems: {\n      exp: [],\n      inc: []\n    },\n    totals: {\n      exp: 0,\n      inc: 0\n    },\n    budget: 0,\n    percentage: -1 //value -1 so we now it doesnt exist yet\n\n  }; //calculates total for either inc or exp\n\n  const calculateTotal = type => {\n    let sum = 0;\n    data.allItems[type].forEach(element => {\n      sum += element.value;\n    });\n    data.totals[type] = sum;\n  }; // gets new ID for addItem()\n\n\n  const getNewID = type => {\n    //select right array according to type\n    let array = data.allItems[type]; //check if any items before\n\n    if (array.length > 0) {\n      return array[array.length - 1].id + 1;\n    } else {\n      return 0;\n    }\n  }; //gets Index of Item\n\n\n  const getIndex = function (type, id) {\n    let ids, index; //need to consider that id != index\n    //map like forEach but returns a new array\n\n    ids = data.allItems[type].map(current => {\n      return current.id;\n    }); //returns the index of the id we are looking for\n\n    return ids.indexOf(id);\n  };\n\n  return {\n    //add an item with the info coming from getter method out of UI\n    addItem: function (type, des, val) {\n      let newItem, id; //Create new id\n\n      id = getNewID(type); //Create new Item based on inc or exp type\n\n      if (type === \"exp\") {\n        newItem = new Expense(id, des, val);\n      } else if (type === \"inc\") {\n        newItem = new Income(id, des, val);\n      } //Push into data structure\n\n\n      data.allItems[type].push(newItem);\n      return newItem;\n    },\n    //edits the data of an item\n    editItem: function (type, id, value) {\n      let index, item; //returns the index of the id we are looking for\n\n      index = getIndex(type, id);\n\n      if (index !== -1) {\n        item = data.allItems[type][index];\n        item.value = value;\n      }\n    },\n    //delete item from data object\n    deleteItem: function (type, id) {\n      let index; //returns the index of the id we are looking for\n\n      index = getIndex(type, id);\n\n      if (index !== -1) {\n        //splice removes elements from our array at position index\n        data.allItems[type].splice(index, 1);\n      }\n    },\n    deleteType: function (type) {\n      //deletes all data of type\n      data.allItems[type] = [];\n    },\n    calculateBudget: function () {\n      //calc total income and expense\n      calculateTotal(\"exp\");\n      calculateTotal(\"inc\"); //calc budget: income - expense\n\n      data.budget = data.totals.inc - data.totals.exp; //calc the percentage of income we spent\n\n      if (data.totals.inc > 0) {\n        data.percentage = Math.round(data.totals.exp / data.totals.inc * 100);\n      } else {\n        data.percentage = -1;\n      }\n    },\n    calculatePercentages: function () {\n      data.allItems.exp.forEach(function (cur) {\n        cur.calcPercentage(data.totals.inc);\n      });\n    },\n    //getter method for budget values. using object because many values\n    getBudget: function () {\n      return {\n        budget: data.budget,\n        totalInc: data.totals.inc,\n        totalExp: data.totals.exp,\n        percentage: data.percentage\n      };\n    },\n    getPercentages: function () {\n      let allPerc = data.allItems.exp.map(function (cur) {\n        return cur.getPercentage();\n      });\n      return allPerc;\n    },\n    testing: function () {\n      calculateTotal(\"exp\");\n      console.log(data);\n    }\n  };\n}(); // UI CONTROLLER\n\n\nlet UIController = function () {\n  //all classnames of html. simple to change later on\n  const DOMstrings = {\n    inputType: \".add__type\",\n    inputDesc: \".add__description\",\n    inputValue: \".add__value\",\n    inputBtn: \".add__btn\",\n    inputBtnDelInc: \".allInc__delete--btn\",\n    inputBtnDelExp: \".allExp__delete--btn\",\n    inputBtnEditInc: \".editInc__item--btn\",\n    inputBtnEditExp: \".editExp__item--btn\",\n    incomeContainer: \".income__list\",\n    expensesContainer: \".expenses__list\",\n    budgetLabel: \".budget__value\",\n    incomeLabel: \".budget__income--value\",\n    expensesLabel: \".budget__expenses--value\",\n    percentageLabel: \".budget__expenses--percentage\",\n    container: \".container\",\n    expensesPercLabel: \".item__percentage\",\n    dateLabel: \".budget__title--month\"\n  };\n\n  const formatNumber = function (num, type) {\n    let numSplit, int, newInt, dec, sign, counter;\n    /* + or - before number\r\n    \t2 decimal poiiiints\r\n    \tcomma separating thousand\r\n    */\n\n    num = Math.abs(num);\n    num = num.toFixed(2); //method from num.prototype - converts to string object\n\n    numSplit = num.split(\".\"); //converts into 2 parts and stores array\n\n    int = numSplit[0];\n    dec = numSplit[1];\n    newInt = int.substr(int.length - 1, 1); //puts the 1000 point\n\n    counter = 1;\n\n    for (let i = int.length - 2; i >= 0; i--) {\n      if (counter % 3 === 0) {\n        newInt = int.substr(i, 1) + \",\" + newInt;\n      } else {\n        newInt = int.substr(i, 1) + newInt;\n      }\n\n      counter++;\n    } //Old solution\n    //int = int.substr(0, int.length - 3) + \",\" + int.substr(int.length - 3);\n\n\n    type === \"inc\" ? sign = \"+\" : sign = \"-\";\n    return sign + \" \" + newInt + \".\" + dec;\n  }; // Custom function to use forEach on nodeList\n\n\n  const nodeListForEach = function (list, callback) {\n    for (let i = 0; i < list.length; i++) {\n      callback(list[i], i);\n    }\n  };\n\n  return {\n    // returns an object with the UI inputs\n    getInput: function () {\n      return {\n        type: document.querySelector(DOMstrings.inputType).value,\n        //either inc or exp\n        description: document.querySelector(DOMstrings.inputDesc).value,\n        value: parseFloat(document.querySelector(DOMstrings.inputValue).value)\n      };\n    },\n    // returns an object with the new inputs - - maybe from pop up box?\n    getEditInput: function () {\n      return {\n        type: document.querySelector(DOMstrings.inputType).value,\n        //either inc or exp\n        description: document.querySelector(DOMstrings.inputDesc).value,\n        value: parseFloat(document.querySelector(DOMstrings.inputValue).value)\n      };\n    },\n    addListItem: function (obj, type) {\n      let html, value;\n      value = formatNumber(obj.value, type); // Create html string with placeholder text - choose between inc and exp\n\n      if (type === \"inc\") {\n        element = DOMstrings.incomeContainer;\n        html = `<div class=\"item clearfix\" id=\"income-${obj.id}\"><div class=\"item__description\">${obj.description}</div><div class=\"right clearfix\"><div class=\"item__value\">+ ${value}</div><div class=\"item__delete\"><button class=\"item__delete--btn\"><i class=\"ion-ios-close-outline\"></i></button></div></div></div>`;\n      } else if (type === \"exp\") {\n        element = DOMstrings.expensesContainer;\n        html = `<div class=\"item clearfix\" id=\"expense-${obj.id}\"><div class=\"item__description\">${obj.description}</div><div class=\"right clearfix\"><div class=\"item__value\">- ${value}</div><div class=\"item__percentage\"> 12%</div><div class=\"item__delete\"><button class=\"item__delete--btn\"><i class=\"ion-ios-close-outline\"></i></button></div></div></div>`;\n      } // Insert HTML into DOM - beforeend so we have it as last element in list\n\n\n      document.querySelector(element).insertAdjacentHTML(\"beforeend\", html);\n    },\n    deleteListItem: function (selectorID) {\n      let el = document.getElementById(selectorID);\n      el.parentNode.removeChild(el);\n    },\n    deleteList: function (type) {\n      let typeContainer, ele; //chooses the right list\n\n      type === \"inc\" ? typeContainer = DOMstrings.incomeContainer : typeContainer = DOMstrings.expensesContainer; //removes children until none\n\n      ele = document.querySelector(typeContainer);\n\n      while (ele.firstChild) {\n        ele.removeChild(ele.firstChild);\n      }\n    },\n    // Clears our input fields\n    clearFields: function () {\n      document.querySelector(DOMstrings.inputDesc).value = \"\";\n      document.querySelector(DOMstrings.inputValue).value = \"\"; //Sets focus back on description field\n\n      document.querySelector(DOMstrings.inputDesc).focus();\n    },\n    // to display the calculated budget items. gets obj with 4 properties\n    displaybudget: function (obj) {\n      let type; //determine if budget is positive for format number\n\n      obj.budget > 0 ? type = \"inc\" : type = \"exp\";\n      document.querySelector(DOMstrings.budgetLabel).textContent = formatNumber(obj.budget, type);\n      document.querySelector(DOMstrings.incomeLabel).textContent = formatNumber(obj.totalInc, \"inc\");\n      document.querySelector(DOMstrings.expensesLabel).textContent = formatNumber(obj.totalExp, \"exp\");\n\n      if (obj.percentage > 0) {\n        document.querySelector(DOMstrings.percentageLabel).textContent = obj.percentage + \"%\";\n      } else {\n        document.querySelector(DOMstrings.percentageLabel).textContent = \"---\";\n      }\n    },\n    displayPercentages: function (percentages) {\n      // dont know what items exactly -> SelectorAll\n      //returns nodeList\n      let fields = document.querySelectorAll(DOMstrings.expensesPercLabel); // Custom ForEach() on nodeList gets used with anon callback func\n\n      nodeListForEach(fields, function (current, index) {\n        // If we have percentage for index we display it via textContent at the html element coming out of fields Nodelist\n        if (percentages[index] > 0) {\n          current.textContent = percentages[index] + \"%\";\n        } else {\n          current.textContent = \"---\";\n        }\n      });\n    },\n    displayMonth: function () {\n      let now, year, month, monthNames;\n      now = new Date();\n      monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n      month = now.getMonth();\n      year = now.getFullYear();\n      document.querySelector(DOMstrings.dateLabel).textContent = monthNames[month] + \" \" + year;\n    },\n    //make the outlines red when expense is selected\n    changedType: function () {\n      var fields = document.querySelectorAll(DOMstrings.inputType + \",\" + DOMstrings.inputDesc + \",\" + DOMstrings.inputValue); //use our custom forEach nodelist\n\n      nodeListForEach(fields, function (cur) {\n        cur.classList.toggle(\"red-focus\");\n      });\n      document.querySelector(DOMstrings.inputBtn).classList.toggle(\"red\");\n    },\n    //making DOMstrings public\n    getDOMstrings: function () {\n      return DOMstrings;\n    }\n  };\n}(); // APP CONTROLLER\n\n\nlet controller = function (budgetCtrl, UICtrl) {\n  //function having all the eventListeners running waiting for User input\n  const setupEventListeners = function () {\n    const DOM = UIController.getDOMstrings(); //for button click on adding budget elements\n\n    document.querySelector(DOM.inputBtn).addEventListener(\"click\", ctrlAddItem); //event listener for return key. called on document object (whole page)\n\n    document.addEventListener(\"keypress\", function (event) {\n      if (event.keyCode === 13 || event.which === 13) {\n        ctrlAddItem();\n      } //bubbles up\n\n\n      document.querySelector(DOM.container).addEventListener(\"click\", ctrlDeleteItem); //event for change of type -> red outline on expenses\n\n      document.querySelector(DOM.inputType).addEventListener(\"change\", UIController.changedType); //event for delete Incomes / Expenses\n\n      document.querySelector(DOM.inputBtnDelInc).addEventListener(\"click\", ctrlDeleteListType);\n      document.querySelector(DOM.inputBtnDelExp).addEventListener(\"click\", ctrlDeleteListType);\n    });\n  }; // Function to-calc the budget\n  // seperate function because we call it on add and delete tiems\n\n\n  const updateBudget = function () {\n    //1. Calc budget\n    budgetController.calculateBudget(); //2. Return budget - getter method\n\n    let budget = budgetController.getBudget(); //3. Display on ui\n\n    UIController.displaybudget(budget);\n  };\n\n  const updatePercentages = function () {\n    //1. Calc the percentages\n    budgetController.calculatePercentages(); //2. Read them form budget Controller\n\n    let percentages = budgetController.getPercentages(); //3. Update UI with new percentages\n\n    UIController.displayPercentages(percentages);\n    console.log(percentages);\n  }; // What happens when new budget element gets added\n\n\n  const ctrlAddItem = function () {\n    let input, newItem; //1. Get field input data\n\n    input = UIController.getInput();\n    console.log(input); // Check for correct input\n\n    if (input.description !== \"\" && !isNaN(input.value) && input.value > 0) {\n      //2. Add item to the budget controller\n      //   getting the created object back from .addItem()\n      newItem = budgetController.addItem(input.type, input.description, input.value); //3. Add item to the UI\n\n      UIController.addListItem(newItem, input.type); //4. Clear fields\n\n      UIController.clearFields(); //calc and update budget\n\n      updateBudget(); //calc and update percentages\n\n      updatePercentages();\n    }\n  };\n\n  const ctrlEditItem = function () {\n    let itemID, splitID, type, id; //get input --- make item input field pop off?? somewehre else?\n\n    input = UIController.getEditInput(); //select the ItemBox\n\n    itemID = event.target.parentNode.parentNode.parentNode.parentNode.id;\n\n    if (itemID) {\n      //split returns array with 2 strings(more with more -): before&after \"-\"\n      splitID = itemID.split(\"-\");\n      type = splitID[0];\n      id = parseInt(splitID[1]); //1. edit item in data structure\n\n      budgetController.editItem(type, id, input); //2. delete item from UI\n\n      UIController.editListItem(itemID); //3. update and show new budget - use method from before\n\n      updateBudget(); //4. calc and update percentages\n\n      updatePercentages();\n    }\n  }; // Delete list items. event is the orginating bubble element\n  //not best solution since hardcoded the DOM path\n\n\n  const ctrlDeleteItem = function (event) {\n    let itemID, splitID, type, id; //selects the ItemBox via id. Has to traverse up\n\n    itemID = event.target.parentNode.parentNode.parentNode.parentNode.id; //only one id in html..on the items\n\n    if (itemID) {\n      //split returns array with 2 strings(more with more -): before&after \"-\"\n      splitID = itemID.split(\"-\");\n      type = splitID[0];\n      id = parseInt(splitID[1]); //1. delete item from data structure\n\n      budgetController.deleteItem(type, id); //2. delete item from UI\n\n      UIController.deleteListItem(itemID); //3. update and show new budget - use method from before\n\n      updateBudget(); //4. calc and update percentages\n\n      updatePercentages();\n    }\n  }; //Deletes whole list of type\n\n\n  const ctrlDeleteListType = function (event) {\n    let type;\n    console.log(event.target.parentNode.classList);\n\n    if (event.target.parentNode.classList.value === \"allInc__delete--btn\") {\n      type = \"inc\";\n    } else if (event.target.parentNode.classList.value === \"allExp__delete--btn\") {\n      type = \"exp\";\n    } // 1. Delete all objects from budgetCtrl\n\n\n    budgetController.deleteType(type); // 2. Remove items from UI\n\n    UIController.deleteList(type); // 3. Rerun budget calc perc calc\n\n    updateBudget();\n    updatePercentages();\n  };\n\n  return {\n    init: function () {\n      console.log(\"App started!\");\n      UIController.displayMonth();\n      setupEventListeners(); //make everything zero on start. inserting custom obj\n\n      UIController.displaybudget({\n        budget: 0,\n        totalInc: 0,\n        totalExp: 0,\n        percentage: -1\n      });\n    }\n  };\n}(budgetController, UIController);\n\ncontroller.init();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5CdWRnZXQgQXBwIHdpdGggRVM1IFN5bnRheFxyXG5cclxuRmVhdHVyZSBJZGVhczpcclxuLXVwZGF0ZSBpbnRvIHByb3BlciBlczYgYW5kIG1vZHVsZXMgKG1lZGl1bSlcclxuLXdlYnBhY2ssIG5wbVxyXG4tRGVsZXRlIGFsbCAoZG9uZSlcclxuLWxvb3AgdG8gbWFrZSB0aGUgdGhvdXNhbmQgbWFya2VyIHdvcmsgd2l0aCBiaWcgbnVtYmVycyhkb25lKVxyXG5cclxuLURhdGUgcGlja2VyKG1lZGl1bT8pXHJcbi1hZGQgY2F0ZWdvcmllcyBhbmQgYSBjaGFydCBzcGxpdCBpbnRvIHRoZSBjYXRlZ29yaWVzIChoYXJkKVxyXG4tYWRkIG1vbnRocyBkcm9wZG93biB3aXRoIHRlbXAgc3RvcmluZyBvZiBtb250aHMgKGhhcmQ/KVxyXG4tZWRpdCBidXR0b24gb24gZWFjaCBsaXN0IGVsZW1lbnQgKG1lZGl1bT8pXHJcblxyXG4tYWRkIHVzZXJzIGFuZCBzYXZpbmcgb2YgZGF0YSB2aWEgTk9ERSBKUyAodmVyeSBoYXJkKVxyXG5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdGVzdCBmcm9tIFwiLi92aWV3XCI7XHJcbmNvbnNvbGUubG9nKHRlc3QpO1xyXG5cclxuLy8gQlVER0VUIENPTlRST0xMRVJcclxubGV0IGJ1ZGdldENvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcblx0Ly8gRXhwZW5zZSBDb25zdHJ1Y3RvclxyXG5cdGNsYXNzIEV4cGVuc2Uge1xyXG5cdFx0Y29uc3RydWN0b3IoaWQsIGRlc2NyaXB0aW9uLCB2YWx1ZSkge1xyXG5cdFx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHRcdHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0XHR0aGlzLnBlcmNlbnRhZ2UgPSAtMTsgLy9ub3QgeWV0IGRlZmluZWRcclxuXHRcdH1cclxuXHRcdC8vIE1ldGhvZDogQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgZnJvbSB0b3RhbFxyXG5cdFx0Y2FsY1BlcmNlbnRhZ2UodG90YWxJbmNvbWUpIHtcclxuXHRcdFx0aWYgKHRvdGFsSW5jb21lID4gMCkge1xyXG5cdFx0XHRcdHRoaXMucGVyY2VudGFnZSA9IE1hdGgucm91bmQoKHRoaXMudmFsdWUgLyB0b3RhbEluY29tZSkgKiAxMDApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucGVyY2VudGFnZSA9IC0xO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRnZXRQZXJjZW50YWdlKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5wZXJjZW50YWdlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEluY29tZSBDb250cnVjdG9yXHJcblx0Y2xhc3MgSW5jb21lIHtcclxuXHRcdGNvbnN0cnVjdG9yKGlkLCBkZXNjcmlwdGlvbiwgdmFsdWUpIHtcclxuXHRcdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0XHR0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGxldCBkYXRhID0ge1xyXG5cdFx0YWxsSXRlbXM6IHtcclxuXHRcdFx0ZXhwOiBbXSxcclxuXHRcdFx0aW5jOiBbXVxyXG5cdFx0fSxcclxuXHRcdHRvdGFsczoge1xyXG5cdFx0XHRleHA6IDAsXHJcblx0XHRcdGluYzogMFxyXG5cdFx0fSxcclxuXHRcdGJ1ZGdldDogMCxcclxuXHRcdHBlcmNlbnRhZ2U6IC0xICAvL3ZhbHVlIC0xIHNvIHdlIG5vdyBpdCBkb2VzbnQgZXhpc3QgeWV0XHJcblx0fTtcclxuXHJcblx0Ly9jYWxjdWxhdGVzIHRvdGFsIGZvciBlaXRoZXIgaW5jIG9yIGV4cFxyXG5cdGNvbnN0IGNhbGN1bGF0ZVRvdGFsID0gdHlwZSA9PiB7XHJcblx0XHRsZXQgc3VtID0gMDtcclxuXHRcdGRhdGEuYWxsSXRlbXNbdHlwZV0uZm9yRWFjaChlbGVtZW50ID0+IHtcclxuXHRcdFx0c3VtICs9IGVsZW1lbnQudmFsdWU7XHJcblx0XHR9KTtcclxuXHRcdGRhdGEudG90YWxzW3R5cGVdID0gc3VtO1xyXG5cdH07XHJcblxyXG5cdC8vIGdldHMgbmV3IElEIGZvciBhZGRJdGVtKClcclxuXHRjb25zdCBnZXROZXdJRCA9IHR5cGUgPT4ge1xyXG5cdFx0Ly9zZWxlY3QgcmlnaHQgYXJyYXkgYWNjb3JkaW5nIHRvIHR5cGVcclxuXHRcdGxldCBhcnJheSA9IGRhdGEuYWxsSXRlbXNbdHlwZV07XHJcblx0XHQvL2NoZWNrIGlmIGFueSBpdGVtcyBiZWZvcmVcclxuXHRcdGlmIChhcnJheS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXS5pZCArIDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvL2dldHMgSW5kZXggb2YgSXRlbVxyXG5cdGNvbnN0IGdldEluZGV4ID0gZnVuY3Rpb24odHlwZSwgaWQpIHtcclxuXHJcblx0XHRsZXQgaWRzLCBpbmRleDtcclxuXHRcdC8vbmVlZCB0byBjb25zaWRlciB0aGF0IGlkICE9IGluZGV4XHJcblx0XHQvL21hcCBsaWtlIGZvckVhY2ggYnV0IHJldHVybnMgYSBuZXcgYXJyYXlcclxuXHRcdGlkcyA9IGRhdGEuYWxsSXRlbXNbdHlwZV0ubWFwKGN1cnJlbnQgPT4ge1xyXG5cdFx0XHRyZXR1cm4gY3VycmVudC5pZDtcclxuXHRcdH0pO1xyXG5cdFx0Ly9yZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgaWQgd2UgYXJlIGxvb2tpbmcgZm9yXHJcblx0XHRyZXR1cm4gaWRzLmluZGV4T2YoaWQpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvL2FkZCBhbiBpdGVtIHdpdGggdGhlIGluZm8gY29taW5nIGZyb20gZ2V0dGVyIG1ldGhvZCBvdXQgb2YgVUlcclxuXHRcdGFkZEl0ZW06IGZ1bmN0aW9uKHR5cGUsIGRlcywgdmFsKSB7XHJcblx0XHRcdGxldCBuZXdJdGVtLCBpZDtcclxuXHRcdFx0Ly9DcmVhdGUgbmV3IGlkXHJcblx0XHRcdGlkID0gZ2V0TmV3SUQodHlwZSk7XHJcblx0XHRcdC8vQ3JlYXRlIG5ldyBJdGVtIGJhc2VkIG9uIGluYyBvciBleHAgdHlwZVxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJleHBcIikge1xyXG5cdFx0XHRcdG5ld0l0ZW0gPSBuZXcgRXhwZW5zZShpZCwgZGVzLCB2YWwpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW5jXCIpIHtcclxuXHRcdFx0XHRuZXdJdGVtID0gbmV3IEluY29tZShpZCwgZGVzLCB2YWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vUHVzaCBpbnRvIGRhdGEgc3RydWN0dXJlXHJcblx0XHRcdGRhdGEuYWxsSXRlbXNbdHlwZV0ucHVzaChuZXdJdGVtKTtcclxuXHRcdFx0cmV0dXJuIG5ld0l0ZW07XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vZWRpdHMgdGhlIGRhdGEgb2YgYW4gaXRlbVxyXG5cdFx0ZWRpdEl0ZW06IGZ1bmN0aW9uKHR5cGUsIGlkLCB2YWx1ZSkge1xyXG5cdFx0XHRsZXQgaW5kZXgsIGl0ZW07XHJcblx0XHRcdC8vcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGlkIHdlIGFyZSBsb29raW5nIGZvclxyXG5cdFx0XHRpbmRleCA9IGdldEluZGV4KHR5cGUsIGlkKTtcclxuXHJcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0XHRpdGVtID0gZGF0YS5hbGxJdGVtc1t0eXBlXVtpbmRleF07XHJcblx0XHRcdFx0aXRlbS52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly9kZWxldGUgaXRlbSBmcm9tIGRhdGEgb2JqZWN0XHJcblx0XHRkZWxldGVJdGVtOiBmdW5jdGlvbih0eXBlLCBpZCkge1xyXG5cdFx0XHRsZXQgaW5kZXg7XHJcblx0XHRcdC8vcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGlkIHdlIGFyZSBsb29raW5nIGZvclxyXG5cdFx0XHRpbmRleCA9IGdldEluZGV4KHR5cGUsIGlkKTtcclxuXHJcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0XHQvL3NwbGljZSByZW1vdmVzIGVsZW1lbnRzIGZyb20gb3VyIGFycmF5IGF0IHBvc2l0aW9uIGluZGV4XHJcblx0XHRcdFx0ZGF0YS5hbGxJdGVtc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdGRlbGV0ZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdFx0Ly9kZWxldGVzIGFsbCBkYXRhIG9mIHR5cGVcclxuXHRcdFx0ZGF0YS5hbGxJdGVtc1t0eXBlXSA9IFtdO1xyXG5cdFx0fSxcclxuXHJcblx0XHRjYWxjdWxhdGVCdWRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHQvL2NhbGMgdG90YWwgaW5jb21lIGFuZCBleHBlbnNlXHJcblx0XHRcdGNhbGN1bGF0ZVRvdGFsKFwiZXhwXCIpO1xyXG5cdFx0XHRjYWxjdWxhdGVUb3RhbChcImluY1wiKTtcclxuXHRcdFx0Ly9jYWxjIGJ1ZGdldDogaW5jb21lIC0gZXhwZW5zZVxyXG5cdFx0XHRkYXRhLmJ1ZGdldCA9IGRhdGEudG90YWxzLmluYyAtIGRhdGEudG90YWxzLmV4cDtcclxuXHRcdFx0Ly9jYWxjIHRoZSBwZXJjZW50YWdlIG9mIGluY29tZSB3ZSBzcGVudFxyXG5cdFx0XHRcdGlmIChkYXRhLnRvdGFscy5pbmMgPiAwKSB7XHJcblx0XHRcdFx0XHRkYXRhLnBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChkYXRhLnRvdGFscy5leHAgLyBkYXRhLnRvdGFscy5pbmMpICogMTAwKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGF0YS5wZXJjZW50YWdlID0gLTE7XHJcblx0XHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRjYWxjdWxhdGVQZXJjZW50YWdlczogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRkYXRhLmFsbEl0ZW1zLmV4cC5mb3JFYWNoKGZ1bmN0aW9uKGN1cikge1xyXG5cdFx0XHRcdGN1ci5jYWxjUGVyY2VudGFnZShkYXRhLnRvdGFscy5pbmMpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vZ2V0dGVyIG1ldGhvZCBmb3IgYnVkZ2V0IHZhbHVlcy4gdXNpbmcgb2JqZWN0IGJlY2F1c2UgbWFueSB2YWx1ZXNcclxuXHRcdGdldEJ1ZGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YnVkZ2V0OiBkYXRhLmJ1ZGdldCxcclxuXHRcdFx0XHR0b3RhbEluYzogZGF0YS50b3RhbHMuaW5jLFxyXG5cdFx0XHRcdHRvdGFsRXhwOiBkYXRhLnRvdGFscy5leHAsXHJcblx0XHRcdFx0cGVyY2VudGFnZTogZGF0YS5wZXJjZW50YWdlXHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFBlcmNlbnRhZ2VzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0bGV0IGFsbFBlcmMgPSBkYXRhLmFsbEl0ZW1zLmV4cC5tYXAoZnVuY3Rpb24oY3VyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGN1ci5nZXRQZXJjZW50YWdlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gYWxsUGVyYztcclxuXHRcdH0sXHJcblxyXG5cdFx0dGVzdGluZzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNhbGN1bGF0ZVRvdGFsKFwiZXhwXCIpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhkYXRhKTtcclxuXHRcdH1cclxuXHR9O1xyXG59KSgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIFVJIENPTlRST0xMRVJcclxuXHJcbmxldCBVSUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKSB7XHJcblx0Ly9hbGwgY2xhc3NuYW1lcyBvZiBodG1sLiBzaW1wbGUgdG8gY2hhbmdlIGxhdGVyIG9uXHJcblx0Y29uc3QgRE9Nc3RyaW5ncyA9IHtcclxuXHRcdGlucHV0VHlwZTogXCIuYWRkX190eXBlXCIsXHJcblx0XHRpbnB1dERlc2M6IFwiLmFkZF9fZGVzY3JpcHRpb25cIixcclxuXHRcdGlucHV0VmFsdWU6IFwiLmFkZF9fdmFsdWVcIixcclxuXHRcdGlucHV0QnRuOiBcIi5hZGRfX2J0blwiLFxyXG5cdFx0aW5wdXRCdG5EZWxJbmM6IFwiLmFsbEluY19fZGVsZXRlLS1idG5cIixcclxuXHRcdGlucHV0QnRuRGVsRXhwOiBcIi5hbGxFeHBfX2RlbGV0ZS0tYnRuXCIsXHJcblx0XHRpbnB1dEJ0bkVkaXRJbmM6IFwiLmVkaXRJbmNfX2l0ZW0tLWJ0blwiLFxyXG5cdFx0aW5wdXRCdG5FZGl0RXhwOiBcIi5lZGl0RXhwX19pdGVtLS1idG5cIixcclxuXHRcdGluY29tZUNvbnRhaW5lcjogXCIuaW5jb21lX19saXN0XCIsXHJcblx0XHRleHBlbnNlc0NvbnRhaW5lcjogXCIuZXhwZW5zZXNfX2xpc3RcIixcclxuXHRcdGJ1ZGdldExhYmVsOiBcIi5idWRnZXRfX3ZhbHVlXCIsXHJcblx0XHRpbmNvbWVMYWJlbDogXCIuYnVkZ2V0X19pbmNvbWUtLXZhbHVlXCIsXHJcblx0XHRleHBlbnNlc0xhYmVsOiBcIi5idWRnZXRfX2V4cGVuc2VzLS12YWx1ZVwiLFxyXG5cdFx0cGVyY2VudGFnZUxhYmVsOiBcIi5idWRnZXRfX2V4cGVuc2VzLS1wZXJjZW50YWdlXCIsXHJcblx0XHRjb250YWluZXI6IFwiLmNvbnRhaW5lclwiLFxyXG5cdFx0ZXhwZW5zZXNQZXJjTGFiZWw6IFwiLml0ZW1fX3BlcmNlbnRhZ2VcIixcclxuXHRcdGRhdGVMYWJlbDogXCIuYnVkZ2V0X190aXRsZS0tbW9udGhcIixcclxuXHR9O1xyXG5cclxuXHRjb25zdCBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihudW0sIHR5cGUpIHtcclxuXHRcdGxldCBudW1TcGxpdCwgaW50LCBuZXdJbnQsIGRlYywgc2lnbiwgY291bnRlcjtcclxuXHRcdC8qICsgb3IgLSBiZWZvcmUgbnVtYmVyXHJcblx0XHRcdDIgZGVjaW1hbCBwb2lpaWludHNcclxuXHRcdFx0Y29tbWEgc2VwYXJhdGluZyB0aG91c2FuZFxyXG5cdFx0Ki9cclxuXHRcdG51bSA9IE1hdGguYWJzKG51bSk7XHJcblx0XHRudW0gPSBudW0udG9GaXhlZCgyKTsgICAgLy9tZXRob2QgZnJvbSBudW0ucHJvdG90eXBlIC0gY29udmVydHMgdG8gc3RyaW5nIG9iamVjdFxyXG5cdFx0bnVtU3BsaXQgPSBudW0uc3BsaXQoXCIuXCIpOyAgLy9jb252ZXJ0cyBpbnRvIDIgcGFydHMgYW5kIHN0b3JlcyBhcnJheVxyXG5cdFx0aW50ID0gbnVtU3BsaXRbMF07XHJcblx0XHRkZWMgPSBudW1TcGxpdFsxXTtcclxuXHRcdG5ld0ludCA9IGludC5zdWJzdHIoaW50Lmxlbmd0aC0xLCAxKTtcclxuXHJcblx0XHQvL3B1dHMgdGhlIDEwMDAgcG9pbnRcclxuXHRcdGNvdW50ZXIgPSAxO1xyXG5cdFx0Zm9yIChsZXQgaSA9IGludC5sZW5ndGgtMjsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKGNvdW50ZXIgJSAzID09PSAwKSB7XHJcblx0XHRcdFx0bmV3SW50ID0gaW50LnN1YnN0cihpLCAxKSArIFwiLFwiICsgbmV3SW50O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5ld0ludCA9IGludC5zdWJzdHIoaSwgMSkgKyBuZXdJbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0Y291bnRlcisrO1xyXG5cdFx0fVxyXG5cdFx0Ly9PbGQgc29sdXRpb25cclxuXHRcdC8vaW50ID0gaW50LnN1YnN0cigwLCBpbnQubGVuZ3RoIC0gMykgKyBcIixcIiArIGludC5zdWJzdHIoaW50Lmxlbmd0aCAtIDMpO1xyXG5cclxuXHRcdHR5cGUgPT09IFwiaW5jXCIgPyBzaWduID0gXCIrXCIgOiBzaWduID0gXCItXCI7XHJcblxyXG5cdFx0cmV0dXJuIHNpZ24gKyBcIiBcIiArIG5ld0ludCArIFwiLlwiICsgZGVjO1xyXG5cdH07XHJcblxyXG5cdC8vIEN1c3RvbSBmdW5jdGlvbiB0byB1c2UgZm9yRWFjaCBvbiBub2RlTGlzdFxyXG5cdGNvbnN0IG5vZGVMaXN0Rm9yRWFjaCA9IGZ1bmN0aW9uIChsaXN0LCBjYWxsYmFjaykge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNhbGxiYWNrKGxpc3RbaV0sIGkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHQvLyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBVSSBpbnB1dHNcclxuXHRcdGdldElucHV0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR0eXBlOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuaW5wdXRUeXBlKS52YWx1ZSwgLy9laXRoZXIgaW5jIG9yIGV4cFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuaW5wdXREZXNjKS52YWx1ZSxcclxuXHRcdFx0XHR2YWx1ZTogcGFyc2VGbG9hdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuaW5wdXRWYWx1ZSkudmFsdWUpLFxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgaW5wdXRzIC0gLSBtYXliZSBmcm9tIHBvcCB1cCBib3g/XHJcblx0XHRnZXRFZGl0SW5wdXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHR5cGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9Nc3RyaW5ncy5pbnB1dFR5cGUpLnZhbHVlLCAvL2VpdGhlciBpbmMgb3IgZXhwXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9Nc3RyaW5ncy5pbnB1dERlc2MpLnZhbHVlLFxyXG5cdFx0XHRcdHZhbHVlOiBwYXJzZUZsb2F0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9Nc3RyaW5ncy5pbnB1dFZhbHVlKS52YWx1ZSksXHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZExpc3RJdGVtOiBmdW5jdGlvbihvYmosIHR5cGUpIHtcclxuXHRcdFx0bGV0IGh0bWwsIHZhbHVlO1xyXG5cclxuXHRcdFx0dmFsdWUgPSBmb3JtYXROdW1iZXIob2JqLnZhbHVlLCB0eXBlKTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBodG1sIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVyIHRleHQgLSBjaG9vc2UgYmV0d2VlbiBpbmMgYW5kIGV4cFxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJpbmNcIikge1xyXG5cdFx0XHRcdGVsZW1lbnQgPSBET01zdHJpbmdzLmluY29tZUNvbnRhaW5lcjtcclxuXHJcblx0XHRcdFx0aHRtbCA9IGA8ZGl2IGNsYXNzPVwiaXRlbSBjbGVhcmZpeFwiIGlkPVwiaW5jb21lLSR7b2JqLmlkfVwiPjxkaXYgY2xhc3M9XCJpdGVtX19kZXNjcmlwdGlvblwiPiR7b2JqLmRlc2NyaXB0aW9ufTwvZGl2PjxkaXYgY2xhc3M9XCJyaWdodCBjbGVhcmZpeFwiPjxkaXYgY2xhc3M9XCJpdGVtX192YWx1ZVwiPisgJHt2YWx1ZX08L2Rpdj48ZGl2IGNsYXNzPVwiaXRlbV9fZGVsZXRlXCI+PGJ1dHRvbiBjbGFzcz1cIml0ZW1fX2RlbGV0ZS0tYnRuXCI+PGkgY2xhc3M9XCJpb24taW9zLWNsb3NlLW91dGxpbmVcIj48L2k+PC9idXR0b24+PC9kaXY+PC9kaXY+PC9kaXY+YDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJleHBcIikge1xyXG5cdFx0XHRcdGVsZW1lbnQgPSBET01zdHJpbmdzLmV4cGVuc2VzQ29udGFpbmVyO1xyXG5cclxuXHRcdFx0XHRodG1sID0gYDxkaXYgY2xhc3M9XCJpdGVtIGNsZWFyZml4XCIgaWQ9XCJleHBlbnNlLSR7b2JqLmlkfVwiPjxkaXYgY2xhc3M9XCJpdGVtX19kZXNjcmlwdGlvblwiPiR7b2JqLmRlc2NyaXB0aW9ufTwvZGl2PjxkaXYgY2xhc3M9XCJyaWdodCBjbGVhcmZpeFwiPjxkaXYgY2xhc3M9XCJpdGVtX192YWx1ZVwiPi0gJHt2YWx1ZX08L2Rpdj48ZGl2IGNsYXNzPVwiaXRlbV9fcGVyY2VudGFnZVwiPiAxMiU8L2Rpdj48ZGl2IGNsYXNzPVwiaXRlbV9fZGVsZXRlXCI+PGJ1dHRvbiBjbGFzcz1cIml0ZW1fX2RlbGV0ZS0tYnRuXCI+PGkgY2xhc3M9XCJpb24taW9zLWNsb3NlLW91dGxpbmVcIj48L2k+PC9idXR0b24+PC9kaXY+PC9kaXY+PC9kaXY+YDtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBJbnNlcnQgSFRNTCBpbnRvIERPTSAtIGJlZm9yZWVuZCBzbyB3ZSBoYXZlIGl0IGFzIGxhc3QgZWxlbWVudCBpbiBsaXN0XHJcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGh0bWwpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkZWxldGVMaXN0SXRlbTogZnVuY3Rpb24oc2VsZWN0b3JJRCkge1xyXG5cdFx0XHRsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RvcklEKTtcclxuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGRlbGV0ZUxpc3Q6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdFx0bGV0IHR5cGVDb250YWluZXIsIGVsZTtcclxuXHRcdFx0Ly9jaG9vc2VzIHRoZSByaWdodCBsaXN0XHJcblx0XHRcdHR5cGUgPT09IFwiaW5jXCIgPyB0eXBlQ29udGFpbmVyID0gRE9Nc3RyaW5ncy5pbmNvbWVDb250YWluZXIgOiB0eXBlQ29udGFpbmVyID0gRE9Nc3RyaW5ncy5leHBlbnNlc0NvbnRhaW5lcjtcclxuXHRcdFx0Ly9yZW1vdmVzIGNoaWxkcmVuIHVudGlsIG5vbmVcclxuXHRcdFx0ZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0eXBlQ29udGFpbmVyKTtcclxuXHRcdFx0d2hpbGUgKGVsZS5maXJzdENoaWxkKSB7XHJcblx0XHRcdCAgIGVsZS5yZW1vdmVDaGlsZChlbGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gQ2xlYXJzIG91ciBpbnB1dCBmaWVsZHNcclxuXHRcdGNsZWFyRmllbGRzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihET01zdHJpbmdzLmlucHV0RGVzYykudmFsdWUgPSBcIlwiO1xyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuaW5wdXRWYWx1ZSkudmFsdWUgPSBcIlwiO1xyXG5cdFx0XHQvL1NldHMgZm9jdXMgYmFjayBvbiBkZXNjcmlwdGlvbiBmaWVsZFxyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuaW5wdXREZXNjKS5mb2N1cygpO1xyXG5cdFx0fSxcclxuXHRcdC8vIHRvIGRpc3BsYXkgdGhlIGNhbGN1bGF0ZWQgYnVkZ2V0IGl0ZW1zLiBnZXRzIG9iaiB3aXRoIDQgcHJvcGVydGllc1xyXG5cdFx0ZGlzcGxheWJ1ZGdldDogZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHQvL2RldGVybWluZSBpZiBidWRnZXQgaXMgcG9zaXRpdmUgZm9yIGZvcm1hdCBudW1iZXJcclxuXHRcdFx0b2JqLmJ1ZGdldCA+IDAgPyB0eXBlID0gXCJpbmNcIiA6IHR5cGUgPSBcImV4cFwiO1xyXG5cclxuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihET01zdHJpbmdzLmJ1ZGdldExhYmVsKS50ZXh0Q29udGVudCA9IGZvcm1hdE51bWJlcihvYmouYnVkZ2V0LCB0eXBlKTtcclxuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihET01zdHJpbmdzLmluY29tZUxhYmVsKS50ZXh0Q29udGVudCA9IGZvcm1hdE51bWJlcihvYmoudG90YWxJbmMsIFwiaW5jXCIpO1xyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuZXhwZW5zZXNMYWJlbCkudGV4dENvbnRlbnQgPSBmb3JtYXROdW1iZXIob2JqLnRvdGFsRXhwLCBcImV4cFwiKTtcclxuXHRcdFx0aWYgKG9iai5wZXJjZW50YWdlID4gMCkge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9Nc3RyaW5ncy5wZXJjZW50YWdlTGFiZWwpLnRleHRDb250ZW50ID0gb2JqLnBlcmNlbnRhZ2UgKyBcIiVcIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MucGVyY2VudGFnZUxhYmVsKS50ZXh0Q29udGVudCA9IFwiLS0tXCI7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzcGxheVBlcmNlbnRhZ2VzOiBmdW5jdGlvbihwZXJjZW50YWdlcykge1xyXG5cdFx0XHQvLyBkb250IGtub3cgd2hhdCBpdGVtcyBleGFjdGx5IC0+IFNlbGVjdG9yQWxsXHJcblx0XHRcdC8vcmV0dXJucyBub2RlTGlzdFxyXG5cdFx0XHRsZXQgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChET01zdHJpbmdzLmV4cGVuc2VzUGVyY0xhYmVsKTtcclxuXHRcdFx0Ly8gQ3VzdG9tIEZvckVhY2goKSBvbiBub2RlTGlzdCBnZXRzIHVzZWQgd2l0aCBhbm9uIGNhbGxiYWNrIGZ1bmNcclxuXHRcdFx0bm9kZUxpc3RGb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oY3VycmVudCwgaW5kZXgpIHtcclxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIHBlcmNlbnRhZ2UgZm9yIGluZGV4IHdlIGRpc3BsYXkgaXQgdmlhIHRleHRDb250ZW50IGF0IHRoZSBodG1sIGVsZW1lbnQgY29taW5nIG91dCBvZiBmaWVsZHMgTm9kZWxpc3RcclxuXHRcdFx0XHRpZiAocGVyY2VudGFnZXNbaW5kZXhdID4gMCkge1xyXG5cdFx0XHRcdFx0Y3VycmVudC50ZXh0Q29udGVudCA9IHBlcmNlbnRhZ2VzW2luZGV4XSArIFwiJVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjdXJyZW50LnRleHRDb250ZW50ID0gXCItLS1cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkaXNwbGF5TW9udGg6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRsZXQgbm93LCB5ZWFyLCBtb250aCwgbW9udGhOYW1lcztcclxuXHRcdFx0bm93ID0gbmV3IERhdGUoKTtcclxuXHRcdFx0bW9udGhOYW1lcyA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcclxuXHRcdFx0bW9udGggPSBub3cuZ2V0TW9udGgoKTtcclxuXHRcdFx0eWVhciA9IG5vdy5nZXRGdWxsWWVhcigpO1xyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTXN0cmluZ3MuZGF0ZUxhYmVsKS50ZXh0Q29udGVudCA9IG1vbnRoTmFtZXNbbW9udGhdKyBcIiBcIiArIHllYXI7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vbWFrZSB0aGUgb3V0bGluZXMgcmVkIHdoZW4gZXhwZW5zZSBpcyBzZWxlY3RlZFxyXG5cdFx0Y2hhbmdlZFR5cGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcclxuXHRcdFx0XHRET01zdHJpbmdzLmlucHV0VHlwZSArIFwiLFwiICtcclxuXHRcdFx0XHRET01zdHJpbmdzLmlucHV0RGVzYyArIFwiLFwiICtcclxuXHRcdFx0XHRET01zdHJpbmdzLmlucHV0VmFsdWUpO1xyXG5cclxuXHRcdFx0Ly91c2Ugb3VyIGN1c3RvbSBmb3JFYWNoIG5vZGVsaXN0XHJcblx0XHRcdG5vZGVMaXN0Rm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGN1cikge1xyXG5cdFx0XHRcdGN1ci5jbGFzc0xpc3QudG9nZ2xlKFwicmVkLWZvY3VzXCIpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9Nc3RyaW5ncy5pbnB1dEJ0bikuY2xhc3NMaXN0LnRvZ2dsZShcInJlZFwiKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly9tYWtpbmcgRE9Nc3RyaW5ncyBwdWJsaWNcclxuXHRcdGdldERPTXN0cmluZ3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gRE9Nc3RyaW5ncztcclxuXHRcdH1cclxuXHR9O1xyXG59KSgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBBUFAgQ09OVFJPTExFUlxyXG5sZXQgY29udHJvbGxlciA9IChmdW5jdGlvbihidWRnZXRDdHJsLCBVSUN0cmwpIHtcclxuXHJcblx0Ly9mdW5jdGlvbiBoYXZpbmcgYWxsIHRoZSBldmVudExpc3RlbmVycyBydW5uaW5nIHdhaXRpbmcgZm9yIFVzZXIgaW5wdXRcclxuXHRjb25zdCBzZXR1cEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRjb25zdCBET00gPSBVSUNvbnRyb2xsZXIuZ2V0RE9Nc3RyaW5ncygpO1xyXG5cdFx0Ly9mb3IgYnV0dG9uIGNsaWNrIG9uIGFkZGluZyBidWRnZXQgZWxlbWVudHNcclxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRE9NLmlucHV0QnRuKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY3RybEFkZEl0ZW0pO1xyXG5cdFx0Ly9ldmVudCBsaXN0ZW5lciBmb3IgcmV0dXJuIGtleS4gY2FsbGVkIG9uIGRvY3VtZW50IG9iamVjdCAod2hvbGUgcGFnZSlcclxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XHJcblx0XHRcdFx0Y3RybEFkZEl0ZW0oKTtcclxuXHRcdFx0fVxyXG5cdFx0Ly9idWJibGVzIHVwXHJcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTS5jb250YWluZXIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjdHJsRGVsZXRlSXRlbSk7XHJcblx0XHQvL2V2ZW50IGZvciBjaGFuZ2Ugb2YgdHlwZSAtPiByZWQgb3V0bGluZSBvbiBleHBlbnNlc1xyXG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihET00uaW5wdXRUeXBlKS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIFVJQ29udHJvbGxlci5jaGFuZ2VkVHlwZSk7XHJcblx0XHQvL2V2ZW50IGZvciBkZWxldGUgSW5jb21lcyAvIEV4cGVuc2VzXHJcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTS5pbnB1dEJ0bkRlbEluYykuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGN0cmxEZWxldGVMaXN0VHlwZSk7XHJcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKERPTS5pbnB1dEJ0bkRlbEV4cCkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGN0cmxEZWxldGVMaXN0VHlwZSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvLyBGdW5jdGlvbiB0by1jYWxjIHRoZSBidWRnZXRcclxuXHQvLyBzZXBlcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIHdlIGNhbGwgaXQgb24gYWRkIGFuZCBkZWxldGUgdGllbXNcclxuXHRjb25zdCB1cGRhdGVCdWRnZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vMS4gQ2FsYyBidWRnZXRcclxuXHRcdGJ1ZGdldENvbnRyb2xsZXIuY2FsY3VsYXRlQnVkZ2V0KCk7XHJcblx0XHQvLzIuIFJldHVybiBidWRnZXQgLSBnZXR0ZXIgbWV0aG9kXHJcblx0XHRsZXQgYnVkZ2V0ID0gYnVkZ2V0Q29udHJvbGxlci5nZXRCdWRnZXQoKTtcclxuXHRcdC8vMy4gRGlzcGxheSBvbiB1aVxyXG5cdFx0VUlDb250cm9sbGVyLmRpc3BsYXlidWRnZXQoYnVkZ2V0KTtcclxuXHR9O1xyXG5cclxuXHRjb25zdCB1cGRhdGVQZXJjZW50YWdlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0Ly8xLiBDYWxjIHRoZSBwZXJjZW50YWdlc1xyXG5cdFx0YnVkZ2V0Q29udHJvbGxlci5jYWxjdWxhdGVQZXJjZW50YWdlcygpO1xyXG5cdFx0Ly8yLiBSZWFkIHRoZW0gZm9ybSBidWRnZXQgQ29udHJvbGxlclxyXG5cdFx0bGV0IHBlcmNlbnRhZ2VzID0gYnVkZ2V0Q29udHJvbGxlci5nZXRQZXJjZW50YWdlcygpO1xyXG5cdFx0Ly8zLiBVcGRhdGUgVUkgd2l0aCBuZXcgcGVyY2VudGFnZXNcclxuXHRcdFVJQ29udHJvbGxlci5kaXNwbGF5UGVyY2VudGFnZXMocGVyY2VudGFnZXMpO1xyXG5cdFx0Y29uc29sZS5sb2cocGVyY2VudGFnZXMpO1xyXG5cdH07XHJcblxyXG5cdC8vIFdoYXQgaGFwcGVucyB3aGVuIG5ldyBidWRnZXQgZWxlbWVudCBnZXRzIGFkZGVkXHJcblx0Y29uc3QgY3RybEFkZEl0ZW0gPSBmdW5jdGlvbigpIHtcclxuXHRcdGxldCBpbnB1dCwgbmV3SXRlbTtcclxuXHRcdC8vMS4gR2V0IGZpZWxkIGlucHV0IGRhdGFcclxuXHRcdGlucHV0ID0gVUlDb250cm9sbGVyLmdldElucHV0KCk7XHJcblx0XHRjb25zb2xlLmxvZyhpbnB1dCk7XHJcblx0XHQvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dFxyXG5cdFx0aWYgKGlucHV0LmRlc2NyaXB0aW9uICE9PSBcIlwiICYmICFpc05hTihpbnB1dC52YWx1ZSkgJiYgaW5wdXQudmFsdWUgPiAwKSB7XHJcblx0XHRcdC8vMi4gQWRkIGl0ZW0gdG8gdGhlIGJ1ZGdldCBjb250cm9sbGVyXHJcblx0XHRcdC8vICAgZ2V0dGluZyB0aGUgY3JlYXRlZCBvYmplY3QgYmFjayBmcm9tIC5hZGRJdGVtKClcclxuXHRcdFx0bmV3SXRlbSA9IGJ1ZGdldENvbnRyb2xsZXIuYWRkSXRlbShcclxuXHRcdFx0XHRpbnB1dC50eXBlLFxyXG5cdFx0XHRcdGlucHV0LmRlc2NyaXB0aW9uLFxyXG5cdFx0XHRcdGlucHV0LnZhbHVlKTtcclxuXHJcblx0XHRcdC8vMy4gQWRkIGl0ZW0gdG8gdGhlIFVJXHJcblx0XHRcdFVJQ29udHJvbGxlci5hZGRMaXN0SXRlbShuZXdJdGVtLCBpbnB1dC50eXBlKTtcclxuXHRcdFx0Ly80LiBDbGVhciBmaWVsZHNcclxuXHRcdFx0VUlDb250cm9sbGVyLmNsZWFyRmllbGRzKCk7XHJcblx0XHRcdC8vY2FsYyBhbmQgdXBkYXRlIGJ1ZGdldFxyXG5cdFx0XHR1cGRhdGVCdWRnZXQoKTtcclxuXHRcdFx0Ly9jYWxjIGFuZCB1cGRhdGUgcGVyY2VudGFnZXNcclxuXHRcdFx0dXBkYXRlUGVyY2VudGFnZXMoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjb25zdCBjdHJsRWRpdEl0ZW0gPSBmdW5jdGlvbigpIHtcclxuXHRcdGxldCBpdGVtSUQsIHNwbGl0SUQsIHR5cGUsIGlkO1xyXG5cdFx0Ly9nZXQgaW5wdXQgLS0tIG1ha2UgaXRlbSBpbnB1dCBmaWVsZCBwb3Agb2ZmPz8gc29tZXdlaHJlIGVsc2U/XHJcblx0XHRpbnB1dCA9IFVJQ29udHJvbGxlci5nZXRFZGl0SW5wdXQoKTtcclxuXHRcdC8vc2VsZWN0IHRoZSBJdGVtQm94XHJcblx0XHRpdGVtSUQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5pZDtcclxuXHRcdGlmIChpdGVtSUQpIHtcclxuXHRcdFx0Ly9zcGxpdCByZXR1cm5zIGFycmF5IHdpdGggMiBzdHJpbmdzKG1vcmUgd2l0aCBtb3JlIC0pOiBiZWZvcmUmYWZ0ZXIgXCItXCJcclxuXHRcdFx0c3BsaXRJRCA9IGl0ZW1JRC5zcGxpdChcIi1cIik7XHJcblx0XHRcdHR5cGUgPSBzcGxpdElEWzBdO1xyXG5cdFx0XHRpZCA9IHBhcnNlSW50KHNwbGl0SURbMV0pO1xyXG5cdFx0XHQvLzEuIGVkaXQgaXRlbSBpbiBkYXRhIHN0cnVjdHVyZVxyXG5cdFx0XHRidWRnZXRDb250cm9sbGVyLmVkaXRJdGVtKHR5cGUsIGlkLCBpbnB1dCk7XHJcblx0XHRcdC8vMi4gZGVsZXRlIGl0ZW0gZnJvbSBVSVxyXG5cdFx0XHRVSUNvbnRyb2xsZXIuZWRpdExpc3RJdGVtKGl0ZW1JRCk7XHJcblx0XHRcdC8vMy4gdXBkYXRlIGFuZCBzaG93IG5ldyBidWRnZXQgLSB1c2UgbWV0aG9kIGZyb20gYmVmb3JlXHJcblx0XHRcdHVwZGF0ZUJ1ZGdldCgpO1xyXG5cdFx0XHQvLzQuIGNhbGMgYW5kIHVwZGF0ZSBwZXJjZW50YWdlc1xyXG5cdFx0XHR1cGRhdGVQZXJjZW50YWdlcygpO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIERlbGV0ZSBsaXN0IGl0ZW1zLiBldmVudCBpcyB0aGUgb3JnaW5hdGluZyBidWJibGUgZWxlbWVudFxyXG5cdC8vbm90IGJlc3Qgc29sdXRpb24gc2luY2UgaGFyZGNvZGVkIHRoZSBET00gcGF0aFxyXG5cdGNvbnN0IGN0cmxEZWxldGVJdGVtID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdGxldCBpdGVtSUQsIHNwbGl0SUQsIHR5cGUsIGlkO1xyXG5cdFx0Ly9zZWxlY3RzIHRoZSBJdGVtQm94IHZpYSBpZC4gSGFzIHRvIHRyYXZlcnNlIHVwXHJcblx0XHRpdGVtSUQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5pZDtcclxuXHRcdC8vb25seSBvbmUgaWQgaW4gaHRtbC4ub24gdGhlIGl0ZW1zXHJcblx0XHRpZiAoaXRlbUlEKSB7XHJcblx0XHRcdC8vc3BsaXQgcmV0dXJucyBhcnJheSB3aXRoIDIgc3RyaW5ncyhtb3JlIHdpdGggbW9yZSAtKTogYmVmb3JlJmFmdGVyIFwiLVwiXHJcblx0XHRcdHNwbGl0SUQgPSBpdGVtSUQuc3BsaXQoXCItXCIpO1xyXG5cdFx0XHR0eXBlID0gc3BsaXRJRFswXTtcclxuXHRcdFx0aWQgPSBwYXJzZUludChzcGxpdElEWzFdKTtcclxuXHRcdFx0Ly8xLiBkZWxldGUgaXRlbSBmcm9tIGRhdGEgc3RydWN0dXJlXHJcblx0XHRcdGJ1ZGdldENvbnRyb2xsZXIuZGVsZXRlSXRlbSh0eXBlLCBpZCk7XHJcblx0XHRcdC8vMi4gZGVsZXRlIGl0ZW0gZnJvbSBVSVxyXG5cdFx0XHRVSUNvbnRyb2xsZXIuZGVsZXRlTGlzdEl0ZW0oaXRlbUlEKTtcclxuXHRcdFx0Ly8zLiB1cGRhdGUgYW5kIHNob3cgbmV3IGJ1ZGdldCAtIHVzZSBtZXRob2QgZnJvbSBiZWZvcmVcclxuXHRcdFx0dXBkYXRlQnVkZ2V0KCk7XHJcblx0XHRcdC8vNC4gY2FsYyBhbmQgdXBkYXRlIHBlcmNlbnRhZ2VzXHJcblx0XHRcdHVwZGF0ZVBlcmNlbnRhZ2VzKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly9EZWxldGVzIHdob2xlIGxpc3Qgb2YgdHlwZVxyXG5cdGNvbnN0IGN0cmxEZWxldGVMaXN0VHlwZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRsZXQgdHlwZTtcclxuXHRcdGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdCk7XHJcblx0XHRpZiAoZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LnZhbHVlID09PSBcImFsbEluY19fZGVsZXRlLS1idG5cIikge1xyXG5cdFx0XHR0eXBlID0gXCJpbmNcIjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGV2ZW50LnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC52YWx1ZSA9PT0gXCJhbGxFeHBfX2RlbGV0ZS0tYnRuXCIpIHtcclxuXHRcdFx0dHlwZSA9IFwiZXhwXCI7XHJcblx0XHR9XHJcblx0XHQvLyAxLiBEZWxldGUgYWxsIG9iamVjdHMgZnJvbSBidWRnZXRDdHJsXHJcblx0XHRidWRnZXRDb250cm9sbGVyLmRlbGV0ZVR5cGUodHlwZSk7XHJcblx0XHQvLyAyLiBSZW1vdmUgaXRlbXMgZnJvbSBVSVxyXG5cdFx0VUlDb250cm9sbGVyLmRlbGV0ZUxpc3QodHlwZSk7XHJcblx0XHQvLyAzLiBSZXJ1biBidWRnZXQgY2FsYyBwZXJjIGNhbGNcclxuXHRcdHVwZGF0ZUJ1ZGdldCgpO1xyXG5cdFx0dXBkYXRlUGVyY2VudGFnZXMoKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQXBwIHN0YXJ0ZWQhXCIpO1xyXG5cdFx0XHRVSUNvbnRyb2xsZXIuZGlzcGxheU1vbnRoKCk7XHJcblx0XHRcdHNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHRcdFx0Ly9tYWtlIGV2ZXJ5dGhpbmcgemVybyBvbiBzdGFydC4gaW5zZXJ0aW5nIGN1c3RvbSBvYmpcclxuXHRcdFx0VUlDb250cm9sbGVyLmRpc3BsYXlidWRnZXQoe1xyXG5cdFx0XHRcdGJ1ZGdldDogMCxcclxuXHRcdFx0XHR0b3RhbEluYzogMCxcclxuXHRcdFx0XHR0b3RhbEV4cDogMCxcclxuXHRcdFx0XHRwZXJjZW50YWdlOiAtMVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG59KShidWRnZXRDb250cm9sbGVyLCBVSUNvbnRyb2xsZXIpO1xyXG5cclxuY29udHJvbGxlci5pbml0KCk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQUNBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUZBO0FBNEZBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXpIQTtBQTJIQTtBQUNBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFaQTtBQWNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (23);\nconst test = \"test\";\nconsole.log(test);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy92aWV3LmpzP2YwNzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgMjM7XHJcblxyXG5jb25zdCB0ZXN0ID0gXCJ0ZXN0XCI7XHJcbmNvbnNvbGUubG9nKHRlc3QpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/view.js\n");

/***/ })

/******/ });